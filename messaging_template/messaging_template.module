<?php
// $Id$
/**
 * @file
 * Drupal Messaging Framework - Messaging template
 */

// Special string for empty text part
define('MESSAGING_TEMPLATE_EMPTY', '<none>');

/**
 * Implementation of hook_help()
 */
function messaging_template_help($path, $arg) {
  switch ($path) {
    case 'admin/messaging/template':
      $output = '<p>' . t('Configure the templates for different types of messages. Each message group is defined by other modules using the Messaging Framework. A typical message consists on the following parts:') . '</p>';
      $output .= '<small><table>';
      $output .= '<tr><td colspan="2"><em>' . t('Subject') . '</em></td><td>' . t('Single line with a short description') . '</td></tr>';
      $output .= '<tr><td rowspan="3">' . t('Body') . '</td><td><em>' . t('Header') . '</em></td><td>' . t('Greetings line') . '</td></tr>';
      $output .= '<tr><td><em>' . t('Content') . '</em></td><td>' . t('Message main content, usually longer with the full description'). '</td></tr>';
      $output .= '<tr><td><em>' . t('Footer') . '</em></td><td>' .  t('Closing part with site information, unsubscribe links, etc...') . '</td></tr>';
      $output .= '</table></small>';
      $output .= '<p>' . t('Here you\'ll be able to configure each of these parts for each sending method. When one of these parts is left blank, there is a fallback system which goes as follows:') . '</p>';
      $output .= '<ul>';
      $output .= '<li>' . t('If a message part is left blank for a sending method, the text part from Default sending method will be used.') . '</li>';
      $output .= '<li>' . t('If the Default part is blank too, the fallback template (the parent in this tree) will be used.') . '</li>';
      $output .= '</ul>';
      return $output;
    default:
      // Edit template groups
      if ($arg[0] == 'admin' && $arg[1] == 'messaging' && $arg[2] == 'template' && $arg[3] == 'edit' && ($group = $arg[4])) {
        $info = messaging_template_message_group($group);
        $output = '<p>'. t('These are the message parts for %group.', array('%group' => messaging_template_message_group($group, 'name')));
        if (!empty($info['description'])) {
          $output .= ' ' . $info['description'];
        }
        $output .= '</p>';
        if (!empty($info['help'])) {
          $output .= '<p>'. $info['help'] .'</p>';
        }
        $output .= '<p>' . t('Leave blank to use the default texts or use \'%empty\' for an empty message part, preventing fallback to default message texts.', array('%empty' => MESSAGING_TEMPLATE_EMPTY));
        if (!empty($info['fallback'])) {
          $output .= ' ' . t('The fallback template from which message parts will be taken if left blank is <a href="@template_edit">%template_name</a>', array('@template_edit' => url('admin/messaging/template/edit/' . $info['fallback']), '%template_name' => messaging_template_message_group($info['fallback'], 'name') ));
        }
        $output .= '</p>';
        return $output;
      }
  }
}

/**
 * Implementation of hook_menu()
 */
function messaging_template_menu() {
  $items['admin/messaging/template'] = array(
    'title' => 'Message templates',
    'description' => 'Configuration of message templates',
    'page callback' => 'messaging_template_admin_template',
    'access arguments' => array('administer messaging'),
    'file' => 'messaging_template.admin.inc',
  );
  $items['admin/messaging/template/edit'] = array(
    'title' => 'Message templates',
    'page callback' => 'messaging_template_admin_template_edit',
    'type' => MENU_CALLBACK,
    'access arguments' => array('administer messaging'),
    'file' => 'messaging_template.admin.inc',
  );
  return $items;
}

/**
 * Returns parts of messages, that may be formatted for each sending method
 *
 * @ TODO Review logic, optimizations, text pre-fetching
 * @ TODO Glue text in a method-dependent way
 *
 * First checks for message, key, method
 * Then checks for message, key for method 'default'
 * Finally checks default values from modules and hook_messaging()
 *
 * @param $group
 *   String, specified by the module where the message originates. ie 'subscriptions-event'.
 * @param $key
 *   String, key for the desired message part.
 * @param $method
 *   String the mailing method that should be used. OPTIONAL
 * @param $getdefault
 *   Boolean, whether to use the default if a specific message isn't available for the used method. OPTIONAL, Defaults to true.
 *
 * @return
 *   Assembled text of a message part.
 */
function messaging_template_message_part($group, $key, $method = 'default', $getdefault = TRUE) {
  $cache = &messaging_static(__FUNCTION__);

  if (!isset($cache[$group][$key][$method])) {
    if ($text = db_result(db_query("SELECT message FROM {messaging_message_parts} WHERE type = '%s' AND msgkey = '%s' AND method = '%s'", $group, $key, $method))){
      $text_part = $text;
    }
    elseif ($getdefault && ($fallback = messaging_template_method_fallback($method))) {
      // Go for method fallback
      $text_part = messaging_template_message_part($group, $key, $fallback);
    }
    elseif ($method == 'default' && ($text = messaging_template_message_info($group, $key))) {
      // Get default from template definitions, convert array into plain text
      $text_part = is_array($text) ? implode("\n", $text) : $text;
    }
    else {
      // Not found, set a FALSE value in the cache so we don't search again
      $text_part = FALSE;
    }
    $cache[$group][$key][$method] = $text_part;
  }

  return $cache[$group][$key][$method];
}

/**
 * Get text part with group and method fallback
 * 
 * @return string
 *   Or NULL if not found
 */
function messaging_template_text_part($group, $key, $method) {
  while ($group) {
    if ($text = messaging_template_message_part($group, $key, $method)) {
      // Found template text, check for empty marker and return
      return $text === MESSAGING_TEMPLATE_EMPTY ? '' : $text;
    }
    else {
      $group = messaging_template_group_fallback($group);
    }
  }
  // If not found, we return Nothing
}

/**
 * Get template type information. It will try to retrieve just this type
 * 
 * @param $type
 *   Template type name
 * @param $property
 *   Optional property to retrieve
 * @param $getall
 *   
 */
function messaging_template_type_info($type = NULL, $property = NULL) {
  $info = &messaging_static(__FUNCTION__);
  if (!isset($info)) {
    $info = module_invoke_all('messaging', 'message groups');
  }
  return messaging_array_info($info, $type, $property);
}

/**
 * Get template fallback
 */
function messaging_template_group_fallback($group) {
  return messaging_template_message_group($group, 'fallback');
}

/**
 * Get method fallback
 * 
 * @todo To be extended. For now it will just return 'default' for any other method
 */
function messaging_template_method_fallback($method) {
  return $method == 'default' ? NULL : 'default';
}

/**
 * Returns parts of messages, that may be formatted for each sending method
 *
 * @param $group
 *   Message group.
 * @param $key
 *   Optional message key inside the group. Returns all keys if null.
 */
function messaging_template_message_info($group, $key = NULL) {
  $info = &messaging_static(__FUNCTION__);
  if (!isset($info[$group])) {
    $info[$group] = module_invoke_all('messaging', 'messages', $group);
  }
  return messaging_array_info($info, $group, $key);
}

/**
 * Returns information about message groups
 *
 * @param $group
 *   Optional message group. Returns all groups if null.
 * @param $key
 *   Optional message key inside the group. Returns all keys if null.
 * @return array()
 *   Depending on parameters, may be all message groups and keys or only a specific one.
 */
function messaging_template_message_group($group = NULL, $key = NULL) {
  static $info;
  
  if (!isset($info)) {
    $info = module_invoke_all('messaging', 'message groups');
  }
  
  return messaging_array_info($info, $group, $key);
}

/**
 * Extract a group of templates from an array of them (including all fallbacks for selected)
 * 
 * @param $filter
 *   Array of template names
 */
function messaging_template_extract_group($filter, $templates) {
  $filter = is_array($filter) ? $filter : array($filter);
  $selected = array();
  foreach ($templates as $key => &$template) {
    if (in_array($key, $filter)) {
      $selected[$key] = $template;
      // Add fallbacks for selected templates too
      while (!empty($template['fallback']) && ($fallback = $template['fallback']) && !isset($selected[$fallback])) { 
        $template = $templates[$fallback];
        $selected[$fallback] = $template;
      }
    }    
  }
  return $selected;
}
/**
 * Do token replacement. 
 * 
 * Uses token_logic if enabled, standard token replacement otherwise
 */
function messaging_template_text_replace($text, $objects) {
  // Add some token types
  $objects['global'] = NULL;  

  // Use token_logic if available, http://code.developmentseed.org/token_logic
  // Otherwise use standard contrib token module, http://drupal.org/project/token
  if (module_exists('token_logic')) {
    return token_logic_replace_multiple($text, $objects);
  }
  else {
    return token_replace_multiple($text, $objects);
  }
}
