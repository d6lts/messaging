<?php
/**
 * @file
 * Simple messaging using html page. Messaging method plug-in
 * 
 * This is a really simple message viewer and also an illustration of pulling messaging methods
 */

/**
 * Implementation of hook_menu().
 */
function messaging_debug_menu($may_cache) {
  global $user;  // we need the user to to build some urls
  $items = array();
  if (!$may_cache) {
    if ($user->uid && arg(0) == 'user' && is_numeric(arg(1)) && (arg(1) == $user->uid)) {
      $items[] = array(
          'path' => 'user/'. $user->uid .'/messagequeue',
          'type' => MENU_LOCAL_TASK,
          'title' => t('Pending messages'),
          'callback' => 'messaging_debug_user_page',
          'callback arguments' => array($user)
      );
    }
  }
  return $items;
}

/**
 * Implementation of hook_form_alter()
 */
function messaging_debug_form_alter($form_id, &$form) {
  if ($form_id == 'messaging_admin_settings') {
    $form['general']['messaging_debug'] = array(
      '#title' => t('Debug mode'),
      '#type' => 'radios',
      '#options' => array(t('Disabled'), t('Enabled')),
      '#default_value' => variable_get('messaging_debug', 0),
      '#description' => t('If enabled, messages wont be sent out but logged to watchdog, and displayed in the page footer.')
    );    
  }
}

/**
 * Menu callback. Display pending messages to the user
 * 
 * Sample Implementation of messaging pull methods
 */
function messaging_debug_user_page($account) {
  drupal_set_title(t('Pending messages for %name', array('%name' => $account->name)));
  // Fetch all pending messages.
  // @ TODO: Add some paging here
  $rows = array();
  // Use this method's info for all the messages
  $simple_info = messaging_method_info('debug');
  foreach (messaging_method_info() as $method => $info) {
    $messages = messaging_pull_pending($method, array($account->uid), 0, FALSE);
    foreach ($messages as $message) {
      $message = messaging_message_render($message, $simple_info);
      $rows[] = array($info['name'], $message['subject'], $message['body']);
    }
  }
  if ($rows) {
    $header = array(t('Method'), t('Subject'), t('Body'));
    return theme('table', $header, $rows);
  } else {
    return t('No pending messages');
  }
}

/**
 * Implementation of hook_messaging
 */
function messaging_debug_messaging($op = 'info') {
  switch($op) {
    case 'send methods':
      $info['debug'] = array(
        'name' => t('Debug'),
        'destination' => 'name',
        'send' => 'messaging_debug_send',
        'send_user' => 'messaging_debug_send_user',
        'type' => MESSAGING_TYPE_PUSH,
        'glue' => '<br />',
        'description' => t('The messages will be just logged to watchdog.'),
      );
      return $info;  
  }
}

/**
 * Just show message title to the user. 
 * 
 * This is a pull method though, so this is mainly intended for testing options
 */
function messaging_debug_send_user($account, $message) {
  $info = messaging_method_info('debug');
  $message = messaging_message_render($message, $info);
  $destination = array($account->name);
  return messaging_debug_send($destination, $message);
}

/**
 * Just show message title to the user. 
 * 
 * This is a pull method though, so this is mainly intended for testing options
 */
function messaging_debug_send($destination, $message) {
  // Just logs everything.
  $text = '';
  $count = 0;
  $watchdog = array();
  foreach ($destination as $name) {
    $text  = t('Message %key for %name: %subject', array('%name' => $name, '%key' => $message['type'], '%subject' => $message['subject']));
    messaging_log($text);
    $watchdog[] = $text;
    $count++;
  }
  $watchdog[] = t('Message body:').'<br /><pre>'.$message['body'].'</pre>';
  // Just log message body at the end
  watchdog('messaging', implode('<br />', $watchdog));
  return $count;
}

/**
 * Implementation of hook_footer()
 * 
 * Only debugging functionality for administrators
 */
function messaging_debug_footer() {
  if (user_access('administer messaging') && ($logs = messaging_log())) {
    $output .= '<div class="messaging-debug">';
    $lines = array();
    foreach ($logs as $log) {
      $lines[] = is_string($log) ? $log : '<pre>'.print_r($log, TRUE).'</pre>';
    }
    $output .= implode('<br/>', $lines);
    $output .= '</div>';
    return $output;
  }
}